- 如何优雅的取随机字符串
```
// 13位
Math.random().toString(16).substring(2)
// 11位
Math.random().toString(36).substring(2)
```

- 取出一个数组中的最大值和最小值
```
var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]
var maxInNumbers = Math.max.apply(Math, numbers)
// => 12205
var minInNumbers = Math.min.apply(Math, numbers)
// => -85411
```

- 使用 `js`获取兼容可用的 样式属性名
```
const getsuitablePropertyName = (name) => {
  let allPrefix = ['', '-webkit-', '-o-', '-ms-']
  let len = allPrefix.length
  let allStyle = document.body.style

  for (let i = 0; i < len; i++) {
    if (allPrefix[i] + name in allStyle) {
      return allPrefix[i] + name
    }
  }
  return null
}

// 用法示例
let suitTransform = getsuitablePropertyName('transform')
console.log(suitTransform)
// -> transform
```

- 使用 `js` 获取 `translate`的浏览器合适写法
```
const getTranslate = () => {
  let allPrefix = ['', '-webkit-', '-o-', '-ms-']
  let len = allPrefix.length
  let ele = document.createElement('div')
  let eleTransform = getsuitablePropertyName('transform')
  let realTranslate = null
  for (let i = 0; i < len; i++) {
    realTranslate = `${allPrefix[i]}translate(0px, 0px)`
    ele.style[eleTransform] = realTranslate
    if (ele.style[eleTransform] === realTranslate) {
      return `${allPrefix[i]}translate`
    }
  }
  return null
}
```

- 使用 `js` 获取 `transitionend`的浏览器合适写法

```
const getTransitionend = () => {
  let allOptions = ['ontransitionend', 'onWebkitTransitionEnd', 'onMozTransitionEnd', 'onOTransitionEnd']
  let len = allOptions.length

  for (let i = 0; i < len; i++) {
    if (allOptions[i] in window) {
      return allOptions[i]
    }
  }
  return null
}
```

`js` 事件的判断属性名称，与真实使用的时候的名称不一定是一样的，所以使用的时候，还要需要稍微处理一下:
```
let suitTransitionend = () => {
  let suitTransitionend = getTransitionend()
  if (suitTransitionend === 'ontransitionend') {
    suitTransitionend = 'transitionend'
  } else {
    suitTransitionend = suitTransitionend.slice(2, 3).toLowerCase() + suitTransitionend.slice(3)
  }
  return suitTransitionend
}

let suitTransitionend = setTransitionend()
document.body.addEventListener(suitTransitionend, ()=>{
    // ...
})
```
- 获取滚动条距离顶部的距离
```
const getScrollTop = () => {
  
  let scrollTop = 0
  if (document.documentElement && document.documentElement.scrollTop) {
    scrollTop = document.documentElement.scrollTop
  } else if (document.body) {
    scrollTop = document.body.scrollTop
  }
  return scrollTop
}
```

- 获取当前可视范围的高度
```
const getClientHeight = () => {
  let clientHeight = 0
  if (document.body.clientHeight && document.documentElement.clientHeight) {
    clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight)
  } else {
    clientHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight)
  }
  return clientHeight
}
```

- 获取文档完整的高度，包括超出屏幕可以滚动显示的部分
```
const getScrollHeight = () => {
  return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
}
```

- 页面链接跳转历史 `URL`不记录的兼容处理
同一个页面中链接的点击不记录 `history`
摘自 [张鑫旭](http://www.zhangxinxu.com/wordpress/2017/02/page-link-url-history-null-not-record/)

```
var fnUrlReplace = function(eleLink) {
  if(!eleLink) {
    return
  }
  var href = eleLink.href
  if(href && /^#|javascript/.test(href) === false) {
    if(history.replaceState()) {
      history.replaceState(null, document.title, href.split('#')[0] + '#')
      location.replace('')
    } else {
    location.replace(href)}
  }
}
```

// 使用如下：
```
document.querySelector('a').onclick = function(event) {
  if(event && event.preventDefault) {
    event.preventDefault()
  }
  fnUrlReplace(this)
  return false
}
```

- js对象浅copy
```
function shallowCopy(src) {
  let dist={}
  for(let i in src) {
    if(src.hasOwnProperty(prop)) {
      dist[prop] = src[prop]
    }
  }
  return dist
}
```

- js对象深copy

>最简单的写法，大部分情况下已经满足需求
  缺点：
  - 无法复制函数(function)
  - 丢失原本的原型链
```
var newObj = JSON.parse(JSON.stringify(obj))
```

>递归实现
```
function deepCopy(o, c) {
  let c = c || {}
  for(let i in o) {
    if(typeof o[i] === 'object'){
      if(o[i].constructor === Array) {
        // 这是数组
         c[i] = []
       } else {
         // 这是对象
         c[i] = {}
       }
       deepCopy(o[i], c[i])
    } else {
      c[i] = o[i]
    }
  }
  return c
}
```

>es6 实现

```
const deepClone = o => {
  // 获取原型链
  let copy = Object.create(Object.getPrototypeOf(o))
  // 获取所有的自有属性
  let propNames = Object.getOwnPropertyNames(o)
  
  propNames.forEach(name => {
    // 获取属性描述符
    let descriptor = Object.getOwnPropertyDescriptor(o, name)
    // 设置属性描述符
    Object.defineProperty(copy, name, desc)
  })
  
  return copy
}
```
