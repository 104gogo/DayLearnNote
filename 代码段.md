- `IE`与标准浏览器之间的样式 `hack`

```
.bb{
    background-color:red;/*所有识别*/
    background-color:#00deff\9; /*IE6、7、8识别*/
    +background-color:#a200ff;/*IE6、7识别*/
    _background-color:#1e0bd1;/*IE6识别*/
}
```

- 清除浮动
```
.clearfix:after{
  content: "020"; 
  display: block; 
  height: 0; 
  clear: both; 
  visibility: hidden;  
}
.clear{
  *zoom:1
}
```

>解析原理：
>1. display:block 使生成的元素以块级元素显示,占满剩余空间; 
>2. height:0 避免生成内容破坏原有布局的高度。
>3. visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;
>4. 通过 content:"."生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，
例如oocss里面就有经典的 content:".",有些版本可能content 里面内容为空,不推荐这样做,
firefox直到7.0 content:”" 仍然会产生额外的空隙
>5. zoom：1 触发IE hasLayout。


- 修改chrome记住密码后自动填充表单的黄色背景
```
input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {
  background-color: rgb(250, 255, 189); /* #FAFFBD; */
  background-image: none;
  color: rgb(0, 0, 0);
}
```

- 将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11
```
function commafy(num){
  return num && num
      .toString()
      .replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
          return $2 + ',';
      });
}
```

- 实现数组的随机排序
```
var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(function(){
    return Math.random() - 0.5;
})
console.log(arr);
```

- `JS` 实现继承关系

>参见 [构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)，
[非构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html)

- 通用的事件侦听器函数， 兼容 `IE` 与标准浏览器
```
standard.Event = {
    // 页面加载完成后
    readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != 'function') {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, function() {
                handler.call(element);
            });
        } else {
            element['on' + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.datachEvent) {
            element.detachEvent('on' + type, handler);
        } else {
            element['on' + type] = null;
        }
    },
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};
```

- 给定一个范围（包括上下边界）以及一个数字n,输出以此范围内n个不重复数字组成的数组

```
// 以下代码没有对 n 是否存在、是否为数字、是否为整数等异常情况做校验，只是一个基本框架
function unique(min, max, n){
    var range = max - min;
    var o = Object.create(null), arr = [], i=0;
    if(n > range+1) {
      console.log('n超出范围');
      return;
    }
    var temp = Math.round(Math.random() * range + min);
    while(i < n){
      if(!o[temp]){
        o[temp] = true;
        arr.push(temp);
        i ++;
      } else {
        temp = Math.round(Math.random() * range + min);
      }
    }
    return arr;
}

```

- `Jquery`判断元素是否物理真实可见
```
// 是否不可见
jQuery.expr.filters.hidden = function( elem ) {
  var width = elem.offsetWidth, height = elem.offsetHeight,
      skip = elem.nodeName.toLowerCase() === "tr";

  // 元素的高度为0，宽度为0， 
  // 并且它不是 <tr>?
  return width === 0 && height === 0 && !skip ?

      // 所以它必须隐藏
      true :

      // 但是如果它拥有高度和宽度值 
      // 并且它不是 <tr>
     width > 0 && height > 0 && !skip ?

        // 所以它必须显示
        false :

            // 如果我们到了这，元素拥有宽度
            // 和高度, 但它也是一个 <tr>,
            // 所以检查显示属性以
            // 确定是否隐藏
            jQuery.curCSS(elem, "display") === "none";
};

// 是否可见
jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
};
```

- 对象复制(包括原型链和自有属性的深度拷贝)
```
function copyObject(orig) {
  var copy = Object.create(Object.getPrototypeOf(orig));
  copyOwnPropertiesFrom(copy, orig);
  return copy;
}

function copyOwnPropertiesFrom(target, source) {
  Object
  .getOwnPropertyNames(source)
  .forEach(function(propKey) {
    var desc = Object.getOwnPropertyDescriptor(source, propKey);
    Object.defineProperty(target, propKey, desc);
  });
  return target;
}
```

- debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。

```
function debounce(func, wait, immediateRun) {
    var timeout,
        startTime = new Date();

    return function() {
        var context = this,
            args = arguments,
            curTime = new Date();

        clearTimeout(timeout);
        // 如果达到了规定的触发时间间隔，触发 handler
        if(curTime - startTime >= immediateRun){
            func.apply(context,args);
            startTime = curTime;
        }else{
            // 没达到触发间隔，重新设定定时器，等待时间 wait秒之后再触发 
            timeout = setTimeout(func, wait);
        }
    };
};
// 实际想绑定在事件上的 handler
function realFunc(){
    console.log("Success");
}
// 如果两次输入之间间隔大于 1000ms ，则立即执行操作，否则就等待 500ms 之后再执行
$('input').on('keydown', debounce(realFunc, 500,1000));
```

- 实时将输入框中的内容转换为大写字母(或者其他操作)

更多关于 setTimeout(fn,time), 参见 [定时器](http://javascript.ruanyifeng.com/advanced/timer.html)
```
document.getElementById('trans').onkeypress=function(){
  var _this=this;
  setTimeout(function(){
    _this.value=_this.value.toUpperCase();
  },0)
}
// setTimeout(fn,0)，注意其中的 0，并不是立即执行的意思，而是等待一个事件执行的队列
// 如果不适用 setTimeout(fn,0)，那么输入的内容将无法对最后输入的字符产生效果
```

- 在老版本浏览器中兼容 `bind()` 函数
```
if(!Function.prototype.bind) {
    Function.prototype.bind = function(obj) {
        var slice=[].slice,
            args=slice.call(arguments,1),
            self=this,
            nop=function(){},
            bound=function(){
                return self.apply(this instanceof nop ? this : (obj || {}),
                                    args.concat(slice.call(arguments)));
            };
        nop.prototype=self.prototype;
        bound.prototype=new nop();
        return bound;
    };
}
```

- `Jquery` `tab`选项卡切换

**`HTML`:**
```
<ul id="tabs">
    <li data-tab="users">Users</li>
    <li data-tab="groups">Groups</li>
</ul>
<div id="tabContent">
    <div data-tab="users"> users-content </div>
    <div data-tab="groups"> groups-content</div>
</div>
```

**`CSS`:**
```
#tabs > li.active {
  color:red;
}
#tabContent > div{
  display: none;
}
#tabContent > div.active {
  display: block;
}
```

**`Jquery`:**
```
jQuery.fn.tabs = function (control) {
    var element = $(this);
    control = $(control);

    // 事件委托，注意 delegate() 函数需要 jquery 1.4.2+
    element.delegate("li", "click", function () {
        // 遍历选项卡名称
        var tabName = $(this).attr("data-tab");
        // 在点击选项卡时触发自定义事件
        element.trigger("change.tabs", tabName);
    });

    // 绑定到自定义事件
    element.bind("change.tabs", function (e, tabName) {
        element.find("li").removeClass("active");
        element.find(">[data-tab='" + tabName + "']").addClass("active");
    });
    element.bind("change.tabs", function (e, tabName) {
        control.find(">[data-tab]").removeClass("active");
        control.find(">[data-tab='" + tabName + "']").addClass("active");
    });
    // 默认激活第 1 个选项卡
    var firstName = element.find("li:first").attr("data-tab");
    element.trigger("change.tabs", firstName);
    return this;
};

// 绑定自定义的 Jquery插件
$("ul#tabs").tabs("#tabContent");
```

- 生成 `GUID`

```
Math.guid = function(){
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    }).toUpperCase();
};
```

- 实现包含关系(`contains`)

```
/*
 * target: 母字符串
 * str: 子字符串
 * separator: 可选，分隔符
 */
function contains(target, str, separator) {
    return separator ? 
           (separator + target + separator).indexOf(separator + str + separator) > -1 :
           target.indexOf(str) > -1;
}
```

- 字符串截断
```
/*
 * target: 需要截断字符串
 * length: 希望字符串被阶段后的长度
 * truncation: 可选，代替所截断多余字符的字符
 */
function truncate(target,length,truncation){
    length=length || 30;
    truncation=truncation===void(0)?'...':truncation;
    return t.length>length ? t.slice(0,length-truncation.length)+truncation : String(t);
}
```

- 移除字符串中的 `html`标签
```
// 如果所需处理的 html字符串中含有 <script> 标签，则需要首先执行这个方法
function stripScripts(target) {
    return String(target || '').replace(/<script[^>]*>([\S\s]*?)<\/script>/img, '');
}
// 处理不包含 <script> 标签的 html字符串
function stripTags(target) {
    return String(target || '').replace(/<+>/g, '');
}
```

- 字符串 `trim`
```
// 简单好记版本
function trim(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

// 速度超快版本(其实还有比这个更快的)
// 前面的空格用正则，后面的用字符串原生方法
function trim(str) {
    str=str.replace(/^\s+/, '');
    var len=str.length-1;
    for(var i=len; i>=0; i--) {
        if(/\S/.test(str.charAt(i))) {
            str=str.substring(0, i+1);
            break;
        }
    }
    return str;
}
```

- 传入日期格式，获取月份的天数

```
function getDaysInMonth(date) {
    // 如果此值等于 28，还可以用来判断是否为闰年
    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
}
```
